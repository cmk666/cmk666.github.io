<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cf-interactive</title>
    <url>/cf-interactive/</url>
    <content><![CDATA[<p>不定时更新。只放 Hard Version。按难度排序。</p>
<h2 id="1089c-2500">1089C *2500</h2>
<p>题意：</p>
<ul>
<li>给你一个仙人掌，边权均为 $1$，你要进行 $n$ 轮交互。</li>
<li>每轮交互，交互库都有一个关键点。</li>
<li>你每次可以询问一个节点 $u$，交互库会返回这个点是否是关键点：若否，则交互库还会返回一个节点 $v$，满足 $u,v$ 有边直接相连且 $v$ 到关键点的距离严格小于 $u$ 到关键点的距离。</li>
<li>每轮交互，你都要在不超过 $10$ 次询问内确定关键点。</li>
<li>$1\le n\le500$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>维护一个答案集合，初始所有点都在里面。</p>
<p>每次选一个到其它点距离和最小的点，容易发现这样一次能排除一半的点。这样只用询问 $\log n$ 次就行了。</p>
<p>可以 floyd 预处理所有距离，这样显然总的是 $O(n^3)$ 的。<a href="//codeforces.com/contest/1089/submission/195240026">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1773i-2500">1773I *2500</h2>
<p>题意：</p>
<ul>
<li>交互库有一个整数 $n$。</li>
<li>每次询问，你可以给出一个 $i$，交互库会返回 $n!$ 在十进制下从低位开始的第 $i$ 位（0-index）。</li>
<li>你要在不超过 $10$ 次询问内唯一确定 $n$。</li>
<li>多测，$1\le t\le100$，$1\le n\le5982$（即，$n!$ 在十进制下的长度 $\le20000$）。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>预处理出所有阶乘，暴力建出决策树即可。容易发现深度 $\le10$，于是一定能唯一确定 $n$。</p>
<p>直接做极有可能会 TLE，要打表前若干层的决策。<a href="//codeforces.com/contest/1773/submission/185401801">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1840g2-2500">1840G2 *2500</h2>
<p>题意：</p>
<ul>
<li>有一个 $n$ 格的转盘，$n$ 未知，每个格子里都有一个数，且所有的数恰好为 $1\sim n$ 的一个排列。一开始指针指向第一格，你也只知道第一格里的数。</li>
<li>你可以把转盘往任意方向转动 $\le10^9$ 格，然后交互库会返回指针当前所指向的格子里的数。</li>
<li>你要在 $1000$ 次（Easy Version 为 $2023$ 次）询问内确定 $n$ 的值。</li>
<li>$1\le n\le 10^6$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>用类似 BSGS 的方法，先跳 $10^3$ 个 $1$，把对应数字记下来，再跳 $10^3$ 个 $10^3$，若重复便能确定 $n$。总询问次数不超过 $2\times10^3$，可以通过 Easy Version。</p>
<p>发现每次询问到的数都 $\le n$，故可以先进行若干次随机跳，搞出 $n$ 的一个较大的下界，然后再用 Easy Version 的方法做即可。</p>
<p>小调一下参就能过 Hard Version 了。<a href="//codeforces.com/contest/1840/submission/211950949">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1090f-2600">1090F *2600</h2>
<p>题意：</p>
<ul>
<li>交互库有一个长为 $n$ 的序列。</li>
<li>你每次可以询问三个位置，交互库会返回这些位置的最大值加上最小值。</li>
<li>你需要在 $4n$ 次询问内还原这个序列。</li>
<li>$5\le n\le1000$，序列中的每个数都是 $[0,10^9]$ 内的整数。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>五个五个一组问。每次暴力枚举 $5!$ 种可能的大小关系，然后相当于每次可以问出两个数的和，容易确定这五个数，暴力 check 是否即可。</p>
<p>询问可以记忆化，总询问次数不超过 $\dbinom53\times\dfrac n5=2n$。<a href="//codeforces.com/contest/1090/submission/195531504">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1765g-2600">1765G *2600</h2>
<p>题意：</p>
<ul>
<li>交互库有一个长为 $n$ 的 $01$ 串 $s$，已知 $s_1=0$。</li>
<li>定义 $p_i$ 为最大的 $j\in[0,i)$ 满足 $s_{1\sim j}$ 和 $s_{i-j+1\sim i}$ 每一位都相同；定义 $q_i$ 为最大的 $j\in[0,i)$ 满足 $s_{1\sim j}$ 和 $s_{i-j+1\sim i}$ 每一位都不相同；</li>
<li>你每次可以询问 $1\ i$，交互库会返回 $p_i$；或询问 $2\ i$，交互库会返回 $q_i$。</li>
<li>你需要在 $789$ 次询问内确定 $01$ 串 $s$。</li>
<li>多测，$1\le t\le 100$，$2\le n\le1000$，交互库不是自适应的。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>显然可以一次先把 $s_2$ 问出来，然后考虑两个两个问。</p>
<p>发现不论先问 $p$ 再问 $q$ 还是先问 $q$ 再问 $p$ 都是最少一次，最多两次问出两个字符，但是随便卡。</p>
<p>所以考虑随机先 $p$ 后 $q$ 还是先 $q$ 后 $p$，这样由于交互库不自适应，就没法把你卡掉了，期望 $\dfrac32$ 次就可以问出两个字符。</p>
<p>总询问次数期望大约在 $\dfrac32\times\dfrac n2=\dfrac{3n}4$ 左右。<a href="//codeforces.com/contest/1765/submission/185019571">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1370f2-2700">1370F2 *2700</h2>
<p>题意：</p>
<ul>
<li>有一个 $n$ 个节点的无根树，和两个关键点 $a,b$。</li>
<li>每次你可以询问一个点集 $S$，交互库会返回 $S$ 内到 $a,b$ 距离之和最近的一个点（有多个并列时随机返回一个）和这个最近的距离之和。</li>
<li>你要在 $11$ 次（Easy Version 为 $14$ 次）询问内确定关键点 $a,b$。</li>
<li>多测，$1\le t\le10$，$2\le n\le1000$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>先把树变成有根树，可以问出两个点深度之和，记作 $d$。问出一个点后，记其深度为 $x$，显然可以询问所有深度为 $d-x$ 的点问出另一个点。</p>
<p>考虑二分来问深度较大的点。每次询问深度 $\ge mid$ 的点，若答案不变则深度 $\ge mid$，反之 $< mid$。于是问出一个点只要 $\log n\le10$ 次。这样的询问次数不多于 $1+10+1=12$ 次，能过 Easy Version。</p>
<p>但是还差一次，只能在二分上优化。由于我们在二分两个点中较深的点，且它们的深度之和为 $d$。所以较深的点深度的下界为 $\left\lceil\dfrac d2\right\rceil$，上界为 $d$。这样的话，二分只用 $\log\dfrac n2\le9$ 次询问。</p>
<p>总询问次数不超过 $1+9+1=11$ 次，可过 Hard Version。<a href="//codeforces.com/contest/1370/submission/195137515">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1491f-2700">1491F *2700</h2>
<p>题意：</p>
<ul>
<li>有 $n$ 个磁铁，每个磁铁要么为正或负极，要么没有磁性。</li>
<li>每次你可以询问两个集合 $S_1,S_2$，交互库会返回 $f(S_1)f(S_2)$，其中 $f(S)$ 表示 $S$ 中正极磁铁数减去负极磁铁数，但你要保证交互库返回的值绝对值 $\le n$。</li>
<li>请在 $n+\lfloor\log_2n\rfloor$ 次询问内找出所有没有磁性的磁铁。</li>
<li>多测，$3\le n,\sum n\le2000$，保证至少有两块磁铁有磁性，至少有一块磁铁没有磁性。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>首先从小到大枚举 $i$，依次询问 $1\sim i-1$ 和 $i$ 之间有没有磁性。当第一次有磁性时，容易说明 $1\sim i-1$ 里恰有一个有磁性，且 $i$ 也有磁性。</p>
<p>对于 $i+1\sim n$ 的磁铁，依次询问 $i$ 和它们有无磁性即可。</p>
<p>对于 $1\sim i-1$ 的磁铁，因为只有一个，直接二分就行了。</p>
<p>前两步总共要 $n-1$ 次询问，第三步不超过 $\log n$ 次询问。总询问次数不多于 $n+\log n-1$，可以通过。<a href="//codeforces.com/contest/1491/submission/198430510">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1715f-2700">1715F *2700</h2>
<p>计算几何，狗都不做！！！！！11</p>
<p>题意：</p>
<ul>
<li>有一个边长为 $1$，边平行于坐标轴的正方形，横坐标 $\in[0,n-1]$，纵坐标 $\in[0,m-1]$（坐标可以不为整数）。</li>
<li>你每次可以询问一个多边形，交互库会返回这个多边形与正方形重叠的面积。</li>
<li>请在 $5$ 次询问内求出正方形左下角的点的位置。</li>
<li>$1\le n,m\le100$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>询问一个竖着的锯齿状物（如图，$n=m=3$），那么容易发现，面积与 $x$ 无关，与 $y$ 成一次函数关系，于是可以求出 $y$。$x$ 同理，旋转 $90\degree$ 即可求出。</p>
<p><img src="/img/1715F.png" alt=""></p>
<p>于是只用两次询问。<a href="//codeforces.com/contest/1715/submission/211084308">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1826f-2800">1826F *2800</h2>
<p>计算几何，狗都不做！！！！！11</p>
<p>题意：</p>
<ul>
<li>平面直角坐标系中有 $n$ 个点。</li>
<li>每次你可以询问一根直线，交互库会以任意顺序返回这些点到这根直线的投影，误差 $10^{-4}$ 以内。</li>
<li>请你用最少的询问次数确定这些点的坐标。</li>
<li>多测，$1\le t\le50$，$1\le n\le25$，保证横纵坐标至少相差 $1$，横纵坐标绝对值 $\le100$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>首先先询问 $x$ 轴和 $y$ 轴，这样可以得知所有点的横纵坐标的精确值，但没法确定它们的相对顺序。</p>
<p>考虑询问一条斜率绝对值很小的直线，这样投影的横坐标和真实值非常接近，然后待定系数法计算出横坐标对应的纵坐标。但是这样误差会很大，不过由于我们已经有纵坐标的精确值，且两个点不会离的太近，直接找精确值里靠的最近的即可。</p>
<p>容易发现，三次是最小的次数。<a href="//codeforces.com/contest/1826/submission/211955057">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1007c-3000">1007C *3000</h2>
<p>题意：</p>
<ul>
<li>交互库有两个值域为 $[1,n]$ 的整数 $a,b$（$n$ 已知）。</li>
<li>每次你可以询问两个整数 $x,y$，若 $x=a\land y=b$，则你猜中了，获胜；否则，交互库会返回 $x< a$，$y< b$，$x>a\lor y>b$ 中的一个（显然，这三个里至少会满足一个，但若同时满足多个，则交互库随机返回一个）。</li>
<li>你要在 $600$ 次询问内猜中 $a,b$。</li>
<li>$1\le n\le10^{18}$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>把两个整数作为一个坐标拍到平面直角坐标系上。维护一个可能成为答案的矩形。</p>
<p>容易发现，若返回 $x< a$ 或 $y< b$，则答案矩形会被横着或竖着切掉一半。考虑把矩形的边界逼近 $(a,b)$，容易想到使用类似倍增的走法，哪边能走就走，同时把这一边的步长加倍。</p>
<p>然而，若返回 $x>a\lor y>b$，则答案矩形会被抠掉一个角，就不再是矩形了。此时回退步长即可。</p>
<p>总询问次数不会超过 $8\log n$。<a href="//codeforces.com/contest/1007/submission/198687618">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1746e2-3200">1746E2 *3200</h2>
<p>题意：</p>
<ul>
<li>交互库有一个 $1\sim n$ 的整数 $x$。</li>
<li>你每次可以询问一个集合，交互库会返回 $x$ 是否在集合中。然而，交互库可能撒谎，但保证相邻两次询问中至少有一次的回答是实话。</li>
<li>你也可以直接猜测一个整数，交互库会返回你是否猜中了 $x$，此时交互库会如实回答。</li>
<li>你要在不超过 $53$ 次（Easy Version 为 $82$ 次）询问和至多 $2$ 次直接猜测中猜出 $x$。</li>
<li>$1\le n\le10^5$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>维护一个答案集合。每次询问，把它分成 $4$ 个部分 $S_0,S_1,S_2,S_3$，而后连续询问 $S_0\cup S_1$ 和 $S_0\cup S_2$。由于交互库不会连续说谎两次，所以这样至少能排除 $S_0,S_1,S_2,S_3$ 的一个：若结果为 YES YES，则排除 $S_3$；若结果为 YES NO，则排除 $S_2$；若结果为 NO YES，则排除 $S_1$；若结果为 NO NO，则排除 $S_0$。</p>
<p>注意到当答案集合只有 $3$ 个元素的时候，需要特判；当只有 $\le2$ 个元素的时候，直接猜就行了。</p>
<p>这样的询问次数大约是 $2\log_{\frac43}n$ 的，能过 Easy Version。</p>
<p>注意到我们并没有充分利用所有的结果，在相邻的两组（四次）询问中，中间两个也至少有一个为真。</p>
<p>我们记当前的答案集合为 $S$，上次询问中我们假装它是对的，得到的集合为 $A$，令 $B=S\setminus A$。现在的目标是选出 $A'\subset A$，$B'\subset B$，询问 $A'\cup B'$，若结果为 YES 则排除 $B\setminus B'$，为 NO 则排除 $B'$。</p>
<p>显然的，我们要让剩下的答案集合越小越好。考虑 dp，设 $dp_{i,j}$ 表示 $|A|=i,|B|=j$ 时的最小询问次数。容易得到：</p>
<p>$$dp_{i,j}=\begin{cases}0&{i+j\le2}\\\min_{0\le x\le i,0\le y\le j}\{\max(dp_{x+y,i-x},dp_{i+j-x-y,x})\}+1&\text{otherwise}\end{cases}$$</p>
<p>顺便记录一下决策，后面直接用即可。</p>
<p>但是上面这个东西是 $O(n^4)$ 的，$n$ 太大跑不动。然而，根据人类智慧，$n$ 很大的时候均分 $A,B$ 也是非常优秀的，所以只要把较小的决策算出来即可。</p>
<p>询问次数很紧，可能需要小调一下参才能过 Hard Version。<a href="//codeforces.com/contest/1746/submission/180716482">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<h2 id="1552h-3300">1552H *3300</h2>
<p>计算几何，狗都不做！！！！！11</p>
<p>题意：</p>
<ul>
<li>有一个四个顶点都是整点，四条边与坐标轴平行的矩形。</li>
<li>你每次可以询问若干个整点，交互库会返回矩形覆盖的点（包括边界）的个数。</li>
<li>你要在不超过 $4$ 次询问中求出矩形的周长。</li>
<li>矩形的顶点坐标 $\in[1,200]$。</li>
</ul>

  <div class="ui accordion">
    <div class=" title">
      <i class="dropdown icon"></i><span>sol</span>
    </div>
    <div class=" content">
      <p style="display: block !important;" class="visible"></p>
      <p>考虑先把所有的点看成 $1\times1$ 的小格子。先把所有点都问一次，把面积问出来。这样只要问出其中一条边的长度就行了。这里设横着的边边长为 $a$，竖着的边边长为 $b$。</p>
<p>尝试每隔 $k$ 行询问，然后把结果乘回 $k$，若仍等于原来的面积，说明 $k\mid b$，反之可以通过二者之差和一共差了几行计算出 $a$。但是一共差了几行这个东西不太好搞，考虑每次询问时的 $k=2^i$，若存在一个 $2^k\mid b\land2^{k+1}\nmid b$，那么后面这次询问时，差的行数恰好就是 $a+1$，于是也就能把 $a$ 算出来。而这个东西显然是可以二分的。</p>
<p>由于 $0\le k\le\log200<8$，所以 $k$ 只有 $8$ 个取值，二分部分只要 $\log_28=3$ 次询问，那么总的询问次数恰好为 $1+3=4$。<a href="//codeforces.com/contest/1552/submission/182256054">submission</a>。</p>

      <p style="display: block !important;" class="visible"></p>
    </div>
  </div>

<p>还剩几个 *3300+ 的题，待填坑。</p>
]]></content>
  </entry>
</search>
